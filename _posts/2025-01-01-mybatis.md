---
title: MyBatis
author: Chu Ying
date: 2025-01-01
category: java
layout: post
---
## 一、基础概念类
### 1. 什么是 MyBatis？它和 JDBC 有什么区别？
#### 什么是 MyBatis？
MyBatis 是一款优秀的半自动化的持久层框架，它封装了几乎所有的 JDBC 底层操作，简化了开发。它的核心思想是将程序中的 SQL 语句剥离出来，配置在 XML 文件或注解中，从而实现 SQL 与 Java 代码的解耦。它通过一套简单的配置，将 Java 对象（POJO）与数据库中的记录进行映射（ORM）。
#### 它和 JDBC 有什么区别？
<table><thead><tr><th align="left">特性</th><th align="left">JDBC (Java Database Connectivity)</th><th align="left">MyBatis</th></tr></thead><tbody><tr><td align="left"><strong>本质</strong></td><td align="left"><strong>Java 访问数据库的标准 API</strong>&#xff0c;是基础。</td><td align="left"><strong>基于 JDBC 的封装和扩展</strong>&#xff0c;是一个框架。</td></tr><tr><td align="left"><strong>SQL 处理</strong></td><td align="left">需要程序员手动编写、拼接复杂的 SQL 字符串在 Java 代码中&#xff0c;容易出错且难以维护。</td><td align="left">SQL 与 Java 代码分离&#xff0c;写在 XML 或注解中&#xff0c;清晰易管理。支持动态 SQL&#xff0c;灵活应对复杂查询。</td></tr><tr><td align="left"><strong>结果集处理</strong></td><td align="left">需要手动编写代码从 <code>ResultSet</code> 中遍历并一个个字段地取出数据&#xff0c;再塞到 Java 对象中&#xff0c;非常繁琐。</td><td align="left"><strong>自动进行 ORM 映射</strong>&#xff0c;通过 <code>&lt;resultMap&gt;</code> 或约定&#xff0c;直接将查询结果映射成 Java 对象&#xff0c;无需手动处理。</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">原生性能最高&#xff0c;但需要开发者自己优化&#xff08;如连接池、预编译等&#xff09;。</td><td align="left">性能接近 JDBC&#xff0c;因为它只是封装了 JDBC。它内置了连接池、预编译语句等优化&#xff0c;开箱即用。</td></tr><tr><td align="left"><strong>开发效率</strong></td><td align="left"><strong>低</strong>。需要大量样板代码&#xff08;注册驱动、获取连接、创建语句、处理异常、关闭资源等&#xff09;。</td><td align="left"><strong>高</strong>。大大减少了冗余代码&#xff0c;开发者只需关注 SQL 和业务逻辑。</td></tr><tr><td align="left"><strong>可移植性</strong></td><td align="left">差&#xff0c;SQL 硬编码在 Java 文件中&#xff0c;更换数据库可能需要修改代码。</td><td align="left">较好&#xff0c;SQL 在配置文件中&#xff0c;更换数据库时主要修改数据库连接配置和少量特定 SQL 语法。</td></tr></tbody></table>
总结：MyBatis 是 JDBC 的“增强版”，它解决了 JDBC 的硬编码、高冗余和繁琐结果集映射等问题，极大地提高了开发效率和代码可维护性。

### 2. MyBatis 的核心组件有哪些？

#### SqlSessionFactoryBuilder (构造器)：
作用： 用于构建 SqlSessionFactory 对象。

生命周期： 最佳作用域是方法作用域。一旦创建了 SqlSessionFactory，它就可以被丢弃。
#### SqlSessionFactory (会话工厂)：
作用： 用于创建 SqlSession 实例。它是线程安全的，一旦被创建，在整个应用运行期间都应该存在。

生命周期： 应用作用域（Application Scope）。通常通过单例模式来管理，一个数据库对应一个 SqlSessionFactory。
#### SqlSession (会话)：
作用： 是 MyBatis 的核心接口，包含了执行 SQL、管理事务、获取 Mapper 等方法。它代表了一次与数据库的会话。

生命周期： 请求或方法作用域。它不是线程安全的！每次收到一个请求，就打开一个 SqlSession，请求处理完毕，必须及时关闭（通常放在 finally 块或使用 try-with-resources 语法）。
#### Executor (执行器)：
作用： MyBatis 的底层核心，真正负责执行 SQL 语句。SqlSession 只是门面，所有数据库操作最终都是通过 Executor 完成的。它负责缓存、动态SQL参数处理等。

类型： SIMPLE（默认）, REUSE, BATCH。
#### MappedStatement (映射语句)：
作用： 它封装了 MyBatis 执行语句的所有信息，例如 SQL 语句、输入参数映射、输出结果映射、缓存配置等。每一个 &lt;select|insert|update|delete&gt; 标签都会被解析成一个 MappedStatement 对象。
#### MapperProxy (Mapper 代理)：
作用： Mapper 接口并没有实现类，MyBatis 使用 JDK 动态代理为 Mapper 接口生成代理对象。当我们调用 UserMapper.selectById() 方法时，实际上调用的是 MapperProxy 的 invoke 方法，它会找到对应的 MappedStatement 并执行。
### 3. MyBatis 的优缺点？适合什么场景？
#### 优点：

* SQL 灵活可控： SQL 由开发者编写，可以针对性地进行优化，满足高性能、复杂查询的需求。
* 学习成本低： 相比于 Hibernate，MyBatis 更容易上手，只要会写 SQL 就能快速使用。
* 与 JDBC 平滑过渡： 性能接近原生 JDBC，且能直接使用数据库的特有功能。
* 良好的解耦： SQL 与 Java 代码分离，代码更清晰，易于维护。
#### 缺点：

* SQL 工作量大： 需要手动编写所有 SQL 语句和结果映射，当表字段多时，比较繁琐。
* 数据库移植性差： SQL 是依赖特定数据库的，如果更换数据库，可能需要重写或调整大量 SQL。
* 半自动化： 不像全自动 ORM 框架那样完全屏蔽数据库，开发者仍需对数据库有一定的了解。
#### 适合场景：
* 需求多变、性能要求高的项目： 如互联网项目，业务逻辑复杂，经常需要优化 SQL。
* 遗留系统或对 SQL 有特殊要求的项目： 需要充分利用数据库特性或处理复杂存储过程。
* 团队 SQL 能力较强： 团队更倾向于直接控制和优化 SQL。
### 4. MyBatis 与 Hibernate 的主要区别？
<table><thead><tr><th align="left">维度</th><th align="left">MyBatis</th><th align="left">Hibernate</th></tr></thead><tbody><tr><td align="left"><strong>ORM 程度</strong></td><td align="left"><strong>半自动化</strong>&#xff0c;需要开发者编写 SQL。</td><td align="left"><strong>全自动化</strong>&#xff0c;完全封装 JDBC&#xff0c;开发者无需关心 SQL。</td></tr><tr><td align="left"><strong>SQL 控制</strong></td><td align="left"><strong>灵活可控</strong>&#xff0c;SQL 优化方便。</td><td align="left"><strong>失去控制权</strong>&#xff0c;由框架生成 SQL&#xff0c;复杂查询优化困难。</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">在复杂、大数据量查询中&#xff0c;由于 SQL 可优化&#xff0c;性能通常更好。</td><td align="left">在小批量、简单 CRUD 场景下效率高。复杂查询可能产生 N&#43;1 问题&#xff0c;性能较差。</td></tr><tr><td align="left"><strong>学习成本</strong></td><td align="left">低&#xff0c;易于上手。</td><td align="left">高&#xff0c;需要掌握 HQL、Criteria API、缓存机制等。</td></tr><tr><td align="left"><strong>数据库移植性</strong></td><td align="left"><strong>差</strong>&#xff0c;SQL 与数据库绑定。</td><td align="left"><strong>好</strong>&#xff0c;使用 HQL 和方言&#xff0c;更换数据库成本低。</td></tr><tr><td align="left"><strong>开发效率</strong></td><td align="left">在简单 CRUD 上不如 Hibernate&#xff0c;在复杂查询上效率高。</td><td align="left">在标准 CRUD 场景下开发效率极高。</td></tr><tr><td align="left"><strong>核心思想</strong></td><td align="left"><strong>SQL 映射</strong>&#xff0c;围绕 SQL 开展工作。</td><td align="left"><strong>对象关系映射</strong>&#xff0c;围绕对象开展工作。</td></tr></tbody></table>
形象比喻：MyBatis 像手动挡汽车，驾驶者可以精准控制速度和性能；Hibernate 像自动挡汽车，驾驶简单，但极限操控不如手动挡。

### 5. MyBatis 是如何实现 SQL 映射的？

MyBatis 的 SQL 映射是其最核心的功能，主要通过以下几步实现：
#### 解析阶段（启动时）：
MyBatis 在应用启动时，会解析全局配置文件（mybatis-config.xml）和所有的 Mapper XML 文件（或注解）。

它会将每一个 SQL 标签（如 <select id="selectUser">）解析成一个 MappedStatement 对象，并将其存储在一个巨大的 Configuration 对象中。MappedStatement 的 Key 通常是 namespace.id（例如 com.example.mapper.UserMapper.selectUser）。
#### 代理阶段（获取 Mapper 时）：
当我们通过 sqlSession.getMapper(UserMapper.class) 获取 Mapper 接口的实例时，MyBatis 会使用 JDK 动态代理为该接口生成一个代理对象（MapperProxy）。
#### 映射与执行阶段（调用方法时）：
当我们调用代理对象的方法时（如 userMapper.selectUser(1)），代理对象 MapperProxy 的 invoke 方法会被触发。
#### 关键步骤：
* a. 定位 MappedStatement： 根据接口的全限定名 + 方法名 组合成 Key，从 Configuration 中找到对应的 MappedStatement。
* b. 参数转换： 将传入的 Java 参数转换为 SQL 执行时所需的参数。
* c. SQL 执行： 将 MappedStatement、参数等信息传递给底层的 Executor 执行器。
* d. 结果映射： Executor 通过 JDBC 执行 SQL 后，获取 ResultSet。然后根据 MappedStatement 中定义的结果映射规则（<resultMap> 或自动映射），将 ResultSet 的一行行数据转换为 Java 对象。
  
总结：MyBatis 通过 “接口全限定名+方法名”作为ID，在启动时建立起一个 SQL 命令的仓库（Configuration），运行时通过动态代理将接口方法调用映射到仓库中具体的 SQL 命令上，最后由执行器完成数据库操作和结果集到 Java 对象的转换。

## 二、SQL 映射与动态 SQL
### 6. #{} 和 ${} 的区别？哪个能防止 SQL 注入？
这是一个非常高频的面试题，考察点在于SQL注入安全和MyBatis的参数处理机制。
<table><thead><tr><th align="left">特性</th><th align="left"><strong><code>#{}</code></strong> (占位符)</th><th align="left"><strong><code>${}</code></strong> (拼接符)</th></tr></thead><tbody><tr><td align="left"><strong>处理方式</strong></td><td align="left"><strong>预编译&#xff08;PreparedStatement&#xff09;</strong></td><td align="left"><strong>字符串直接替换&#xff08;Statement&#xff09;</strong></td></tr><tr><td align="left"><strong>安全性</strong></td><td align="left"><strong>能有效防止SQL注入</strong></td><td align="left"><strong>不能防止SQL注入&#xff0c;存在安全风险</strong></td></tr><tr><td align="left"><strong>底层实现</strong></td><td align="left">会被解析成 <code>?</code>&#xff0c;然后使用 <code>PreparedStatement.setXxx()</code> 方法来安全地设置参数。</td><td align="left">会将 <code>${}</code> 内的内容<strong>原样</strong>拼接在SQL语句中&#xff0c;然后编译执行。</td></tr><tr><td align="left"><strong>数据库优化</strong></td><td align="left">数据库可以对预编译的SQL进行缓存&#xff0c;有利于性能优化。</td><td align="left">每次都是一个新的SQL语句&#xff0c;无法利用预编译缓存。</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left"><strong>传入参数的值</strong>&#xff08;Where条件中的值&#xff0c;Insert的值等&#xff09;。<strong>99%的场景都应使用<code>#{}</code></strong>。</td><td align="left"><strong>动态传入表名、列名等非值参数</strong>。例如&#xff1a; <code>ORDER BY ${columnName}</code>。</td></tr><tr><td align="left"><strong>示例</strong></td><td align="left"><code>SELECT * FROM user WHERE name &#61; #{name}</code> 解析为&#xff1a;<code>SELECT * FROM user WHERE name &#61; ?</code>&#xff0c;参数 <code>‘Alice’</code> 会被安全地设置进去。</td><td align="left"><code>SELECT * FROM ${tableName} WHERE name &#61; ${name}</code> 如果 <code>tableName</code> 为 <code>user</code>&#xff0c;<code>name</code> 为 <code>‘Alice’</code>&#xff0c;则解析为&#xff1a; <code>SELECT * FROM user WHERE name &#61; Alice</code>&#xff08;语法错误&#xff09; 如果 <code>name</code> 被恶意传入 <code>‘Alice’ OR ‘1’&#61;‘1’</code>&#xff0c;则解析为&#xff1a; <code>SELECT * FROM user WHERE name &#61; Alice OR ‘1’&#61;‘1’</code>&#xff08;查询出所有数据&#xff0c;SQL注入成功&#xff09;。</td></tr></tbody></table>
结论：
* #{} 能防止SQL注入，应优先使用。
* ${} 有SQL注入风险，除非是动态表名/列名等必须使用字符串替换的场景，否则严禁使用。

### 7. MyBatis 中如何处理字段名与属性名不一致？
当数据库字段名（如 user_name）和 Java 实体类属性名（如 userName）不一致时，查询结果无法自动映射。有三种解决方案：

#### 1.起别名（最原始）
在 SQL 语句中为字段起一个与属性名相同的别名。
<div style="white-space: pre-wrap">
<div style="font-size: 1.125em; font-weight: bold;">  【流程图】</div>
Service 调用数据访问方法
    ↓
Mapper 接口接收调用 (定义于 Repository/DAO 层)
    ↓
MyBatis 为 Mapper 接口生成代理实现
    ↓
代理对象解析方法名 → 查找对应的 SQL 映射
    ↓
SQL 映射文件 (或注解) 中定义的 SQL 语句
    ↓
MyBatis 创建 SqlSession → 获取数据库连接
    ↓
执行器 Executor 处理 SQL 执行
    ↓
参数处理器设置 PreparedStatement 参数
    ↓
执行 SQL 语句
    ↓
结果集处理器 ResultHandler 转换结果
    ↓
TypeHandler 进行 Java 类型与 JDBC 类型转换
    ↓
将结果集映射为 Java 对象/集合 (Entity 或 DTO)
    ↓
数据返回 → Mapper 接口 → Service
    ↓
Service 继续处理业务逻辑
    ↓
返回最终结果给 Controller
</div>
