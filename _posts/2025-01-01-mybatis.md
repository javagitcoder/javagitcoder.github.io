---
title: MyBatis
author: Chu Ying
date: 2025-01-01
category: java
layout: post
---
<div style="white-space: pre-wrap">
<div style="font-size: 1.25em; font-weight: bold;">一、基础概念类</div>
<div style="font-size: 1.125em; font-weight: bold;">1.1什么是 MyBatis？</div>
MyBatis 是一款优秀的半自动化的持久层框架，它封装了几乎所有的 JDBC 底层操作，简化了开发。
它的核心思想是将程序中的 SQL 语句剥离出来，配置在 XML 文件或注解中，从而实现 SQL 与 Java 代码的解耦。
它通过一套简单的配置，将 Java 对象（POJO）与数据库中的记录进行映射（ORM）。
<div style="font-size: 1.125em; font-weight: bold;"> 1.2它和 JDBC 有什么区别？</div>
</div>
<table>
  <tr>
    <th>特性</th>
    <th>JDBC (Java Database Connectivity)</th>
    <th>MyBatis</th>
  </tr>
  <tr>
    <td>本质</td>
    <td>Java 访问数据库的标准 API，是基础。</td>
    <td>基于 JDBC 的封装和扩展，是一个框架。</td>
  </tr>
  <tr>
    <td>SQL 处理</td>
    <td>需要程序员手动编写、拼接复杂的 SQL 字符串在 Java 代码中，容易出错且难以维护。</td>
    <td>SQL 与 Java 代码分离，写在 XML 或注解中，清晰易管理。支持动态 SQL，灵活应对复杂查询。</td>
  </tr>
  <tr>
    <td>结果集处理</td>
    <td>需要手动编写代码从 ResultSet 中遍历并一个个字段地取出数据，再塞到 Java 对象中，非常繁琐。</td>
    <td>自动进行 ORM 映射，通过 &lt;resultMap&gt; 或约定，直接将查询结果映射成 Java 对象，无需手动处理。</td>
  </tr>
  <tr>
    <td>性能</td>
    <td>原生性能最高，但需要开发者自己优化（如连接池、预编译等）。</td>
    <td>性能接近 JDBC，因为它只是封装了 JDBC。它内置了连接池、预编译语句等优化，开箱即用。</td>
  </tr>
  <tr>
    <td>开发效率</td>
    <td>低。需要大量样板代码（注册驱动、获取连接、创建语句、处理异常、关闭资源等）。</td>
    <td>高。大大减少了冗余代码，开发者只需关注 SQL 和业务逻辑。</td>
  </tr>
  <tr>
    <td>可移植性</td>
    <td>差，SQL 硬编码在 Java 文件中，更换数据库可能需要修改代码。</td>
    <td>较好，SQL 在配置文件中，更换数据库时主要修改数据库连接配置和少量特定 SQL 语法。</td>
  </tr>
</table>
<div style="white-space: pre-wrap">
总结：MyBatis 是 JDBC 的“增强版”，它解决了 JDBC 的硬编码、高冗余和繁琐结果集映射等问题，
极大地提高了开发效率和代码可维护性。

<div style="font-size: 1.125em; font-weight: bold;"> 2. MyBatis 的核心组件有哪些？</div>

<div style="font-size: 1em; font-weight: bold;"> SqlSessionFactoryBuilder (构造器)：</div>
作用： 用于构建 SqlSessionFactory 对象。
生命周期： 最佳作用域是方法作用域。一旦创建了 SqlSessionFactory，它就可以被丢弃。

<div style="font-size: 1em; font-weight: bold;"> SqlSessionFactory (会话工厂)：</div>
作用： 用于创建 SqlSession 实例。它是线程安全的，一旦被创建，在整个应用运行期间都应该存在。
生命周期： 应用作用域（Application Scope）。通常通过单例模式来管理，一个数据库对应一个 SqlSessionFactory。

<div style="font-size: 1em; font-weight: bold;"> SqlSession (会话)：</div>
作用： 是 MyBatis 的核心接口，包含了执行 SQL、管理事务、获取 Mapper 等方法。它代表了一次与数据库的会话。
生命周期： 请求或方法作用域。它不是线程安全的！每次收到一个请求，就打开一个 SqlSession，请求处理完毕，必须及时关闭（通常放在 finally 块或使用 try-with-resources 语法）。

<div style="font-size: 1em; font-weight: bold;"> Executor (执行器)：</div>
作用： MyBatis 的底层核心，真正负责执行 SQL 语句。SqlSession 只是门面，所有数据库操作最终都是通过 Executor 完成的。它负责缓存、动态SQL参数处理等。
类型： SIMPLE（默认）, REUSE, BATCH。

<div style="font-size: 1em; font-weight: bold;"> MappedStatement (映射语句)：</div>
作用： 它封装了 MyBatis 执行语句的所有信息，例如 SQL 语句、输入参数映射、输出结果映射、缓存配置等。每一个 <select|insert|update|delete> 标签都会被解析成一个 MappedStatement 对象。
  
<div style="font-size: 1em; font-weight: bold;"> MapperProxy (Mapper 代理)：</div>
作用： Mapper 接口并没有实现类，MyBatis 使用 JDK 动态代理为 Mapper 接口生成代理对象。当我们调用 UserMapper.selectById() 方法时，实际上调用的是 MapperProxy 的 invoke 方法，它会找到对应的 MappedStatement 并执行。

<div style="font-size: 1.125em; font-weight: bold;"> 3. MyBatis 的优缺点？适合什么场景？</div>
<span style=" font-weight: bold;">优点：</span>
<span style=" font-weight: bold;">SQL 灵活可控：</span>SQL 由开发者编写，可以针对性地进行优化，满足高性能、复杂查询的需求。
学习成本低： 相比于 Hibernate，MyBatis 更容易上手，只要会写 SQL 就能快速使用。
与 JDBC 平滑过渡： 性能接近原生 JDBC，且能直接使用数据库的特有功能。
良好的解耦： SQL 与 Java 代码分离，代码更清晰，易于维护。
<span style=" font-weight: bold;">缺点：</span>
<span style=" font-weight: bold;">SQL 工作量大：</span> 需要手动编写所有 SQL 语句和结果映射，当表字段多时，比较繁琐。
数据库移植性差： SQL 是依赖特定数据库的，如果更换数据库，可能需要重写或调整大量 SQL。
半自动化： 不像全自动 ORM 框架那样完全屏蔽数据库，开发者仍需对数据库有一定的了解。
<span style=" font-weight: bold;">适合场景：</span>
需求多变、性能要求高的项目： 如互联网项目，业务逻辑复杂，经常需要优化 SQL。
遗留系统或对 SQL 有特殊要求的项目： 需要充分利用数据库特性或处理复杂存储过程。
团队 SQL 能力较强： 团队更倾向于直接控制和优化 SQL。
<div style="font-size: 1.125em; font-weight: bold;">4. MyBatis 与 Hibernate 的主要区别？</div>
</div>
<div style="white-space: pre-wrap">
Service 调用数据访问方法
    ↓
Mapper 接口接收调用 (定义于 Repository/DAO 层)
    ↓
MyBatis 为 Mapper 接口生成代理实现
    ↓
代理对象解析方法名 → 查找对应的 SQL 映射
    ↓
SQL 映射文件 (或注解) 中定义的 SQL 语句
    ↓
MyBatis 创建 SqlSession → 获取数据库连接
    ↓
执行器 Executor 处理 SQL 执行
    ↓
参数处理器设置 PreparedStatement 参数
    ↓
执行 SQL 语句
    ↓
结果集处理器 ResultHandler 转换结果
    ↓
TypeHandler 进行 Java 类型与 JDBC 类型转换
    ↓
将结果集映射为 Java 对象/集合 (Entity 或 DTO)
    ↓
数据返回 → Mapper 接口 → Service
    ↓
Service 继续处理业务逻辑
    ↓
返回最终结果给 Controller
</div>
