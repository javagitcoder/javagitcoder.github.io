---
title: MyBatis
author: Chu Ying
date: 2025-01-01
category: java
layout: post
---
## 一、基础概念类
### 1. 什么是 MyBatis？它和 JDBC 有什么区别？
#### 什么是 MyBatis？
MyBatis 是一款优秀的半自动化的持久层框架，它封装了几乎所有的 JDBC 底层操作，简化了开发。它的核心思想是将程序中的 SQL 语句剥离出来，配置在 XML 文件或注解中，从而实现 SQL 与 Java 代码的解耦。它通过一套简单的配置，将 Java 对象（POJO）与数据库中的记录进行映射（ORM）。
#### 它和 JDBC 有什么区别？
<table><thead><tr><th align="left">特性</th><th align="left">JDBC (Java Database Connectivity)</th><th align="left">MyBatis</th></tr></thead><tbody><tr><td align="left"><strong>本质</strong></td><td align="left"><strong>Java 访问数据库的标准 API</strong>&#xff0c;是基础。</td><td align="left"><strong>基于 JDBC 的封装和扩展</strong>&#xff0c;是一个框架。</td></tr><tr><td align="left"><strong>SQL 处理</strong></td><td align="left">需要程序员手动编写、拼接复杂的 SQL 字符串在 Java 代码中&#xff0c;容易出错且难以维护。</td><td align="left">SQL 与 Java 代码分离&#xff0c;写在 XML 或注解中&#xff0c;清晰易管理。支持动态 SQL&#xff0c;灵活应对复杂查询。</td></tr><tr><td align="left"><strong>结果集处理</strong></td><td align="left">需要手动编写代码从 <code style="color: red;">ResultSet</code> 中遍历并一个个字段地取出数据&#xff0c;再塞到 Java 对象中&#xff0c;非常繁琐。</td><td align="left"><strong>自动进行 ORM 映射</strong>&#xff0c;通过 <code style="color: red;">&lt;resultMap&gt;</code> 或约定&#xff0c;直接将查询结果映射成 Java 对象&#xff0c;无需手动处理。</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">原生性能最高&#xff0c;但需要开发者自己优化&#xff08;如连接池、预编译等&#xff09;。</td><td align="left">性能接近 JDBC&#xff0c;因为它只是封装了 JDBC。它内置了连接池、预编译语句等优化&#xff0c;开箱即用。</td></tr><tr><td align="left"><strong>开发效率</strong></td><td align="left"><strong>低</strong>。需要大量样板代码&#xff08;注册驱动、获取连接、创建语句、处理异常、关闭资源等&#xff09;。</td><td align="left"><strong>高</strong>。大大减少了冗余代码&#xff0c;开发者只需关注 SQL 和业务逻辑。</td></tr><tr><td align="left"><strong>可移植性</strong></td><td align="left">差&#xff0c;SQL 硬编码在 Java 文件中&#xff0c;更换数据库可能需要修改代码。</td><td align="left">较好&#xff0c;SQL 在配置文件中&#xff0c;更换数据库时主要修改数据库连接配置和少量特定 SQL 语法。</td></tr></tbody></table>
总结：MyBatis 是 JDBC 的“增强版”，它解决了 JDBC 的硬编码、高冗余和繁琐结果集映射等问题，极大地提高了开发效率和代码可维护性。

### 2. MyBatis 的核心组件有哪些？

#### SqlSessionFactoryBuilder (构造器)：
作用： 用于构建 SqlSessionFactory 对象。

生命周期： 最佳作用域是方法作用域。一旦创建了 SqlSessionFactory，它就可以被丢弃。
#### SqlSessionFactory (会话工厂)：
作用： 用于创建 SqlSession 实例。它是线程安全的，一旦被创建，在整个应用运行期间都应该存在。

生命周期： 应用作用域（Application Scope）。通常通过单例模式来管理，一个数据库对应一个 SqlSessionFactory。
#### SqlSession (会话)：
作用： 是 MyBatis 的核心接口，包含了执行 SQL、管理事务、获取 Mapper 等方法。它代表了一次与数据库的会话。

生命周期： 请求或方法作用域。它不是线程安全的！每次收到一个请求，就打开一个 SqlSession，请求处理完毕，必须及时关闭（通常放在 finally 块或使用 try-with-resources 语法）。
#### Executor (执行器)：
作用： MyBatis 的底层核心，真正负责执行 SQL 语句。SqlSession 只是门面，所有数据库操作最终都是通过 Executor 完成的。它负责缓存、动态SQL参数处理等。

类型： SIMPLE（默认）, REUSE, BATCH。
#### MappedStatement (映射语句)：
作用： 它封装了 MyBatis 执行语句的所有信息，例如 SQL 语句、输入参数映射、输出结果映射、缓存配置等。每一个 &lt;select|insert|update|delete&gt; 标签都会被解析成一个 MappedStatement 对象。
#### MapperProxy (Mapper 代理)：
作用： Mapper 接口并没有实现类，MyBatis 使用 JDK 动态代理为 Mapper 接口生成代理对象。当我们调用 UserMapper.selectById() 方法时，实际上调用的是 MapperProxy 的 invoke 方法，它会找到对应的 MappedStatement 并执行。
### 3. MyBatis 的优缺点？适合什么场景？
#### 优点：

* SQL 灵活可控： SQL 由开发者编写，可以针对性地进行优化，满足高性能、复杂查询的需求。
* 学习成本低： 相比于 Hibernate，MyBatis 更容易上手，只要会写 SQL 就能快速使用。
* 与 JDBC 平滑过渡： 性能接近原生 JDBC，且能直接使用数据库的特有功能。
* 良好的解耦： SQL 与 Java 代码分离，代码更清晰，易于维护。
#### 缺点：

* SQL 工作量大： 需要手动编写所有 SQL 语句和结果映射，当表字段多时，比较繁琐。
* 数据库移植性差： SQL 是依赖特定数据库的，如果更换数据库，可能需要重写或调整大量 SQL。
* 半自动化： 不像全自动 ORM 框架那样完全屏蔽数据库，开发者仍需对数据库有一定的了解。
#### 适合场景：
* 需求多变、性能要求高的项目： 如互联网项目，业务逻辑复杂，经常需要优化 SQL。
* 遗留系统或对 SQL 有特殊要求的项目： 需要充分利用数据库特性或处理复杂存储过程。
* 团队 SQL 能力较强： 团队更倾向于直接控制和优化 SQL。
### 4. MyBatis 与 Hibernate 的主要区别？
<table><thead><tr><th align="left">维度</th><th align="left">MyBatis</th><th align="left">Hibernate</th></tr></thead><tbody><tr><td align="left"><strong>ORM 程度</strong></td><td align="left"><strong>半自动化</strong>&#xff0c;需要开发者编写 SQL。</td><td align="left"><strong>全自动化</strong>&#xff0c;完全封装 JDBC&#xff0c;开发者无需关心 SQL。</td></tr><tr><td align="left"><strong>SQL 控制</strong></td><td align="left"><strong>灵活可控</strong>&#xff0c;SQL 优化方便。</td><td align="left"><strong>失去控制权</strong>&#xff0c;由框架生成 SQL&#xff0c;复杂查询优化困难。</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">在复杂、大数据量查询中&#xff0c;由于 SQL 可优化&#xff0c;性能通常更好。</td><td align="left">在小批量、简单 CRUD 场景下效率高。复杂查询可能产生 N&#43;1 问题&#xff0c;性能较差。</td></tr><tr><td align="left"><strong>学习成本</strong></td><td align="left">低&#xff0c;易于上手。</td><td align="left">高&#xff0c;需要掌握 HQL、Criteria API、缓存机制等。</td></tr><tr><td align="left"><strong>数据库移植性</strong></td><td align="left"><strong>差</strong>&#xff0c;SQL 与数据库绑定。</td><td align="left"><strong>好</strong>&#xff0c;使用 HQL 和方言&#xff0c;更换数据库成本低。</td></tr><tr><td align="left"><strong>开发效率</strong></td><td align="left">在简单 CRUD 上不如 Hibernate&#xff0c;在复杂查询上效率高。</td><td align="left">在标准 CRUD 场景下开发效率极高。</td></tr><tr><td align="left"><strong>核心思想</strong></td><td align="left"><strong>SQL 映射</strong>&#xff0c;围绕 SQL 开展工作。</td><td align="left"><strong>对象关系映射</strong>&#xff0c;围绕对象开展工作。</td></tr></tbody></table>
形象比喻：MyBatis 像手动挡汽车，驾驶者可以精准控制速度和性能；Hibernate 像自动挡汽车，驾驶简单，但极限操控不如手动挡。

### 5. MyBatis 是如何实现 SQL 映射的？

MyBatis 的 SQL 映射是其最核心的功能，主要通过以下几步实现：
#### 解析阶段（启动时）：
MyBatis 在应用启动时，会解析全局配置文件（mybatis-config.xml）和所有的 Mapper XML 文件（或注解）。

它会将每一个 SQL 标签（如 &lt;select id="selectUser"&gt;）解析成一个 MappedStatement 对象，并将其存储在一个巨大的 Configuration 对象中。MappedStatement 的 Key 通常是 namespace.id（例如 com.example.mapper.UserMapper.selectUser）。
#### 代理阶段（获取 Mapper 时）：
当我们通过 sqlSession.getMapper(UserMapper.class) 获取 Mapper 接口的实例时，MyBatis 会使用 JDK 动态代理为该接口生成一个代理对象（MapperProxy）。
#### 映射与执行阶段（调用方法时）：
当我们调用代理对象的方法时（如 userMapper.selectUser(1)），代理对象 MapperProxy 的 invoke 方法会被触发。
#### 关键步骤：
* a. 定位 MappedStatement： 根据接口的全限定名 + 方法名 组合成 Key，从 Configuration 中找到对应的 MappedStatement。
* b. 参数转换： 将传入的 Java 参数转换为 SQL 执行时所需的参数。
* c. SQL 执行： 将 MappedStatement、参数等信息传递给底层的 Executor 执行器。
* d. 结果映射： Executor 通过 JDBC 执行 SQL 后，获取 ResultSet。然后根据 MappedStatement 中定义的结果映射规则（<resultMap> 或自动映射），将 ResultSet 的一行行数据转换为 Java 对象。
  
总结：MyBatis 通过 “接口全限定名+方法名”作为ID，在启动时建立起一个 SQL 命令的仓库（Configuration），运行时通过动态代理将接口方法调用映射到仓库中具体的 SQL 命令上，最后由执行器完成数据库操作和结果集到 Java 对象的转换。

## 二、SQL 映射与动态 SQL
### 6. #{} 和 ${} 的区别？哪个能防止 SQL 注入？
这是一个非常高频的面试题，考察点在于SQL注入安全和MyBatis的参数处理机制。
<table><thead><tr><th align="left">特性</th><th align="left"><strong><code style="color: red;">#{}</code></strong> (占位符)</th><th align="left"><strong><code style="color: red;">${}</code></strong> (拼接符)</th></tr></thead><tbody><tr><td align="left"><strong>处理方式</strong></td><td align="left"><strong>预编译&#xff08;PreparedStatement&#xff09;</strong></td><td align="left"><strong>字符串直接替换&#xff08;Statement&#xff09;</strong></td></tr><tr><td align="left"><strong>安全性</strong></td><td align="left"><strong>能有效防止SQL注入</strong></td><td align="left"><strong>不能防止SQL注入&#xff0c;存在安全风险</strong></td></tr><tr><td align="left"><strong>底层实现</strong></td><td align="left">会被解析成 <code style="color: red;">?</code>&#xff0c;然后使用 <code style="color: red;">PreparedStatement.setXxx()</code> 方法来安全地设置参数。</td><td align="left">会将 <code style="color: red;">${}</code> 内的内容<strong>原样</strong>拼接在SQL语句中&#xff0c;然后编译执行。</td></tr><tr><td align="left"><strong>数据库优化</strong></td><td align="left">数据库可以对预编译的SQL进行缓存&#xff0c;有利于性能优化。</td><td align="left">每次都是一个新的SQL语句&#xff0c;无法利用预编译缓存。</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left"><strong>传入参数的值</strong>&#xff08;Where条件中的值&#xff0c;Insert的值等&#xff09;。<strong>99%的场景都应使用<code style="color: red;">#{}</code></strong>。</td><td align="left"><strong>动态传入表名、列名等非值参数</strong>。例如&#xff1a; <code style="color: red;">ORDER BY ${columnName}</code>。</td></tr><tr><td align="left"><strong>示例</strong></td><td align="left"><code style="color: red;">SELECT * FROM user WHERE name &#61; #{name}</code> 解析为&#xff1a;<code style="color: red;">SELECT * FROM user WHERE name &#61; ?</code>&#xff0c;参数 <code style="color: red;">‘Alice’</code> 会被安全地设置进去。</td><td align="left"><code style="color: red;">SELECT * FROM ${tableName} WHERE name &#61; ${name}</code> 如果 <code style="color: red;">tableName</code> 为 <code style="color: red;">user</code>&#xff0c;<code style="color: red;">name</code> 为 <code style="color: red;">‘Alice’</code>&#xff0c;则解析为&#xff1a; <code style="color: red;">SELECT * FROM user WHERE name &#61; Alice</code>&#xff08;语法错误&#xff09; 如果 <code style="color: red;">name</code> 被恶意传入 <code style="color: red;">‘Alice’ OR ‘1’&#61;‘1’</code>&#xff0c;则解析为&#xff1a; <code style="color: red;">SELECT * FROM user WHERE name &#61; Alice OR ‘1’&#61;‘1’</code>&#xff08;查询出所有数据&#xff0c;SQL注入成功&#xff09;。</td></tr></tbody></table>
结论：
* #{} 能防止SQL注入，应优先使用。
* ${} 有SQL注入风险，除非是动态表名/列名等必须使用字符串替换的场景，否则严禁使用。

### 7. MyBatis 中如何处理字段名与属性名不一致？
当数据库字段名（如 user_name）和 Java 实体类属性名（如 userName）不一致时，查询结果无法自动映射。有三种解决方案：

#### 1.起别名（最原始）
在 SQL 语句中为字段起一个与属性名相同的别名。
```sql
SELECT user_id as id, user_name as userName FROM user;
```
#### 2.使用 resultMap（最强大、最常用）
定义一个 &lt;resultMap&gt; 来精确地指定数据库字段和Java属性的映射关系。这是最推荐的方式。
```xml
<resultMap id="UserResultMap" type="com.example.User">
    <id property="id" column="user_id"/>
    <result property="userName" column="user_name"/>
    <!-- 其他字段映射 -->
</resultMap>

<select id="selectUser" resultMap="UserResultMap">
    SELECT * FROM user
</select>
```
#### 3.开启驼峰命名自动映射（最方便）
在 MyBatis 的全局配置文件中（如 application.yml 或 mybatis-config.xml）设置 mapUnderscoreToCamelCase 为 true。MyBatis 会自动将下划线风格的字段名（user_name）转换为驼峰风格的属性名（userName）。
```sql
# application.yml
mybatis:
  configuration:
    map-underscore-to-camel-case: true
```
### 8. resultType 和 resultMap 的区别？
<table><thead><tr><th align="left">特性</th><th align="left"><strong><code>resultType</code></strong></th><th align="left"><strong><code>resultMap</code></strong></th></tr></thead><tbody><tr><td align="left"><strong>映射方式</strong></td><td align="left"><strong>自动映射</strong></td><td align="left"><strong>手动映射</strong></td></tr><tr><td align="left"><strong>灵活性</strong></td><td align="left">低。要求查询返回的列名&#xff08;或别名&#xff09;必须与Java对象的属性名<strong>严格一致</strong>&#xff08;或开启驼峰映射&#xff09;。</td><td align="left">高。可以自定义复杂的映射关系&#xff0c;解决任何字段名和属性名不一致的问题。</td></tr><tr><td align="left"><strong>功能</strong></td><td align="left">只能简单映射。</td><td align="left">功能强大&#xff0c;可以处理&#xff1a; 1. 字段名/属性名不一致。 2. <strong>复杂类型关联&#xff08;一对一、一对多&#xff09;</strong>。 3. 继承关系映射。</td></tr><tr><td align="left"><strong>使用场景</strong></td><td align="left">查询结果非常简单&#xff0c;且字段名与属性名完全对应。</td><td align="left">所有需要自定义映射规则的场景&#xff0c;尤其是有关联查询时<strong>必须使用</strong>。</td></tr></tbody></table>
总结：resultType 是自动挡，简单省事但受限；resultMap 是手动挡，操控精准功能强。

### 9. MyBatis 动态 SQL 有哪些标签？执行原理是？
动态SQL标签：
<ul><li><strong><code>&lt;if&gt;</code></strong>&#xff1a; 条件判断。</li><li><strong><code>&lt;choose&gt;、&lt;when&gt;、&lt;otherwise&gt;</code></strong>&#xff1a; 类似 Java 中的 <code>switch-case-default</code>&#xff0c;实现多选一。</li><li><strong><code>&lt;trim&gt;、&lt;where&gt;、&lt;set&gt;</code></strong>&#xff1a; 智能地处理SQL语句的前缀、后缀和多余的连接词&#xff08;如AND&#xff0c; OR&#xff0c; 逗号&#xff09;。
<ul><li><code>&lt;where&gt;</code> 会智能地去掉开头多余的 <code>AND</code>/<code>OR</code>。</li><li><code>&lt;set&gt;</code> 会智能地去掉结尾多余的逗号。</li></ul>
</li><li><strong><code>&lt;foreach&gt;</code></strong>&#xff1a; 遍历集合&#xff0c;常用于 <code>IN</code> 条件或批量操作。</li></ul>

```xml
<!-- 示例：批量查询 -->
<select id="selectUsersByIds" resultType="User">
    SELECT * FROM user WHERE id IN
    <foreach collection="ids" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
</select>
```

<p><strong>执行原理</strong>&#xff1a;<br />
MyBatis 的动态 SQL 功能是基于 <strong>OGNL (Object-Graph Navigation Language)</strong> 表达式和内部强大的 <code>SqlNode</code>、<code>SqlSource</code> 等组件实现的。</p>
<ol><li><strong>解析阶段</strong>&#xff1a; 在应用启动时&#xff0c;MyBatis 会解析 Mapper XML 文件。它会将动态 SQL 标签解析成一个个 <code>SqlNode</code> 对象&#xff0c;形成一个<strong>混合的静态/动态 SQL 树状结构</strong>。</li>
  <li><strong>执行阶段</strong>&#xff1a; 当执行 SQL 时&#xff0c;MyBatis 会传入参数对象。</li>
  <li><strong>应用OGNL</strong>&#xff1a; MyBatis 会使用 OGNL 表达式来评估动态标签中的判断条件&#xff08;如 <code>&lt;if test&#61;&#34;name !&#61; null&#34;&gt;</code>&#xff09;。</li>
  <li><strong>拼接SQL</strong>&#xff1a; 根据评估结果&#xff08;true/false&#xff09;&#xff0c;<code>SqlNode</code> 会动态地拼接出最终的、完整的 SQL 字符串。<code>&lt;where&gt;</code>, <code>&lt;set&gt;</code> 等标签会在此过程中智能地处理语法问题。</li>
  <li><strong>参数设置</strong>&#xff1a; 最终&#xff0c;这个拼接好的 SQL 会被交给 <code>PreparedStatement</code>&#xff0c;并使用 <code>#{}</code> 占位符的方式安全地设置参数。</li>
</ol>

### 10. 如何实现一对多、多对一、多对多关联查询&#xff1f;
<p>主要通过 <code>&lt;association&gt;</code> 和 <code>&lt;collection&gt;</code> 标签在 <code>&lt;resultMap&gt;</code> 中实现。</p>
<ul><li><strong>多对一 / 一对一 (<code>&lt;association&gt;</code>)</strong>&#xff1a;<br />
例如&#xff1a;多个订单属于一个用户&#xff08;多对一&#xff09;。</li></ul>
```xml
<resultMap id="OrderWithUserResultMap" type="Order">
    <!-- 映射Order本身的基本字段 -->
    <id property="id" column="order_id"/>
    <result property="orderNumber" column="order_number"/>
    
    <!-- association 映射关联的单个User对象 -->
    <association property="user" javaType="User">
        <id property="id" column="user_id"/>
        <result property="userName" column="user_name"/>
    </association>
</resultMap>

<select id="selectOrderWithUser" resultMap="OrderWithUserResultMap">
    SELECT o.order_id, o.order_number, u.user_id, u.user_name
    FROM orders o LEFT JOIN user u ON o.user_id = u.user_id
    WHERE o.order_id = #{id}
</select>
```
* 一对多 (&lt;collection&gt;)：

例如：一个用户有多个订单（一对多）。
```xml
<resultMap id="UserWithOrdersResultMap" type="User">
    <!-- 映射User本身的基本字段 -->
    <id property="id" column="user_id"/>
    <result property="userName" column="user_name"/>
    
    <!-- collection 映射关联的Order集合 -->
    <collection property="orders" ofType="Order">
        <id property="id" column="order_id"/>
        <result property="orderNumber" column="order_number"/>
    </collection>
</resultMap>

<select id="selectUserWithOrders" resultMap="UserWithOrdersResultMap">
    SELECT u.user_id, u.user_name, o.order_id, o.order_number
    FROM user u LEFT JOIN orders o ON u.user_id = o.user_id
    WHERE u.user_id = #{id}
</select>
```
* 多对多：

多对多关系需要借助中间表。例如：用户和角色。一个用户有多个角色，一个角色属于多个用户。查询用户及其角色列表，本质上仍然是一对多查询，只是关联关系通过中间表实现。
```xml
<resultMap id="UserWithRolesResultMap" type="User">
    <id property="id" column="user_id"/>
    <result property="userName" column="user_name"/>
    <!-- 角色集合 -->
    <collection property="roles" ofType="Role">
        <id property="roleId" column="role_id"/>
        <result property="roleName" column="role_name"/>
    </collection>
</resultMap>

<select id="selectUserWithRoles" resultMap="UserWithRolesResultMap">
    SELECT u.user_id, u.user_name, r.role_id, r.role_name
    FROM user u
    LEFT JOIN user_role ur ON u.user_id = ur.user_id
    LEFT JOIN role r ON ur.role_id = r.role_id
    WHERE u.user_id = #{id}
</select>
```
### 11. MyBatis 支持延迟加载吗？原理是？
支持。延迟加载（懒加载）是 MyBatis 提供的一种优化手段。

什么是延迟加载？
在关联查询（如查询用户及其订单）时，默认情况下（急加载），MyBatis 会通过一条复杂的联表SQL将主对象（用户）和关联对象（订单）的数据一次性全部查询出来。
而延迟加载的意思是：先查询主对象（用户）。只有当程序真正去访问主对象中的关联对象（如调用 user.getOrders() 方法）时，MyBatis 才会发起第二条SQL去查询关联的订单数据。

如何开启？

在全局配置中开启：
```sql
mybatis:
  configuration:
    lazy-loading-enabled: true       # 开启延迟加载
    aggressive-lazy-loading: false   # 禁用“侵略性”延迟加载（重要）
```
* 原理是什么？
  
MyBatis 的实现非常巧妙，它利用了 动态代理。

1. 当你执行查询主对象的SQL时（如 selectUserById），MyBatis 返回的 User 对象中，orders 属性并不是真正的 List&lt;Order&gt;，而是一个由 MyBatis 生成的、实现了 List&lt;Order&gt; 接口的代理对象。

2. 这个代理对象内部保存了能够单独查询订单数据的SQL语句和参数。

3. 当你第一次调用 user.getOrders() 方法时，这个代理对象会被触发，它去执行之前保存的SQL，查询出真正的订单数据，然后返回给你。

* 优点： 提高了性能，特别是在不需要使用关联数据的情况下，避免了执行复杂SQL和传输多余数据。

* 缺点： 可能会遇到著名的 “N+1 查询问题”。如果先查询一个用户列表（1条SQL），然后遍历每个用户并访问其订单（N条SQL），就会产生大量数据库查询，反而降低性能。因此，延迟加载需要根据业务场景谨慎使用。
## 三、缓存机制
### 12. MyBatis 的一级缓存和二级缓存区别？
这道题要求对MyBatis的两级缓存有全局的理解。以下是核心区别的对比：

<div style="white-space: pre-wrap">
<div style="font-size: 1.125em; font-weight: bold;">  【流程图】</div>
Service 调用数据访问方法
    ↓
Mapper 接口接收调用 (定义于 Repository/DAO 层)
    ↓
MyBatis 为 Mapper 接口生成代理实现
    ↓
代理对象解析方法名 → 查找对应的 SQL 映射
    ↓
SQL 映射文件 (或注解) 中定义的 SQL 语句
    ↓
MyBatis 创建 SqlSession → 获取数据库连接
    ↓
执行器 Executor 处理 SQL 执行
    ↓
参数处理器设置 PreparedStatement 参数
    ↓
执行 SQL 语句
    ↓
结果集处理器 ResultHandler 转换结果
    ↓
TypeHandler 进行 Java 类型与 JDBC 类型转换
    ↓
将结果集映射为 Java 对象/集合 (Entity 或 DTO)
    ↓
数据返回 → Mapper 接口 → Service
    ↓
Service 继续处理业务逻辑
    ↓
返回最终结果给 Controller
</div>
